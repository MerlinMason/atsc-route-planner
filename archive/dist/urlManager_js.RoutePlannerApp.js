"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkroute_planner"] = self["webpackChunkroute_planner"] || []).push([["urlManager_js"],{

/***/ "./urlManager.js":
/*!***********************!*\
  !*** ./urlManager.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createMarkersFromURLData: () => (/* binding */ createMarkersFromURLData),\n/* harmony export */   decodePointsFromUrl: () => (/* binding */ decodePointsFromUrl),\n/* harmony export */   encodePointsToUrl: () => (/* binding */ encodePointsToUrl),\n/* harmony export */   generateShareableURL: () => (/* binding */ generateShareableURL),\n/* harmony export */   handleURLParameters: () => (/* binding */ handleURLParameters),\n/* harmony export */   initializeURLHandling: () => (/* binding */ initializeURLHandling),\n/* harmony export */   processURLParameters: () => (/* binding */ processURLParameters)\n/* harmony export */ });\n/* harmony import */ var lz_string__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lz-string */ \"./node_modules/lz-string/libs/lz-string.js\");\n/* harmony import */ var lz_string__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lz_string__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _state_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./state.js */ \"./state.js\");\n/* harmony import */ var _geometryUtils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./geometryUtils.js */ \"./geometryUtils.js\");\n/* harmony import */ var _apiUtils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./apiUtils.js */ \"./apiUtils.js\");\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n// urlManager.js - URL data manipulation, parsing and actions\n\n\n\n\n\n/**\n * Initializes URL handling\n * @param {Object} appState - The application state manager\n * @returns {Promise} Promise resolving when URL handling is complete\n */\nfunction initializeURLHandling(appState) {\n  console.log('Initializing URL handling...');\n\n  // Return the promise directly\n  return handleURLParameters(appState);\n}\n\n/**\n * Handles URL parameters for shared routes\n * @param {Object} appState - Application state manager\n * @returns {Promise} Promise resolving when handling is complete\n */\nfunction handleURLParameters(appState) {\n  console.log('Checking for URL parameters...');\n\n  // Return the promise chain explicitly\n  return decodePointsFromUrl().then(function (pointsDataFromUrl) {\n    if (pointsDataFromUrl) {\n      console.log('Found route data in URL:', pointsDataFromUrl);\n      return processURLPoints(appState, pointsDataFromUrl);\n    } else {\n      // No URL parameters, check localStorage for saved route\n      console.log('No URL parameters found, checking localStorage...');\n      return checkLocalStorage(appState);\n    }\n  }).catch(function (error) {\n    console.error('Error handling URL parameters:', error);\n  });\n}\n\n/**\n * Processes points data from URL\n * @param {Object} appState - Application state manager\n * @param {Array} pointsDataFromUrl - Points data from URL\n * @returns {Promise} Promise resolving when processing is complete\n */\nfunction processURLPoints(appState, pointsDataFromUrl) {\n  return Promise.all([Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./routeProcessor.js */ \"./routeProcessor.js\")), Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./apiUtils.js */ \"./apiUtils.js\"))]).then(function (_ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n      routeProcessor = _ref2[0],\n      apiUtils = _ref2[1];\n    // First create the markers\n    return createMarkersFromURLData(appState, pointsDataFromUrl);\n  }).then(function () {\n    // When route loading completes, fit to route\n    return __webpack_require__.e(/*! import() */ \"viewportManager_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./viewportManager.js */ \"./viewportManager.js\")).then(function (viewportManager) {\n      viewportManager.fitMapToRouteExplicit(appState);\n    });\n  }).catch(function (error) {\n    console.error('Error processing route from URL:', error);\n    Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./modal.js */ \"./modal.js\")).then(function (modalModule) {\n      modalModule.showModal({\n        text: 'Failed to load the shared route. Please try again.'\n      });\n    });\n    return Promise.reject(error);\n  });\n}\n\n/**\n * Checks localStorage for saved route\n * @param {Object} appState - Application state manager\n * @returns {Promise} Promise resolving when check is complete\n */\nfunction checkLocalStorage(appState) {\n  var routeData = localStorage.getItem('routeData');\n  var pointsData = localStorage.getItem('points');\n  if (routeData && pointsData) {\n    console.log(\"Found route and points data in localStorage\");\n\n    // Parse data\n    var parsedPoints = JSON.parse(pointsData);\n    var parsedRouteData = JSON.parse(routeData);\n    if (parsedPoints.length < 2) {\n      return Promise.resolve();\n    }\n\n    // Extract points\n    var startPoint = parsedPoints[0];\n    var endPoint = parsedPoints[parsedPoints.length - 1];\n    var middlePoints = parsedPoints.slice(1, -1);\n\n    // Update this to use routeProcessor directly\n    return Promise.all([Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./markerManager.js */ \"./markerManager.js\")), Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./routeProcessor.js */ \"./routeProcessor.js\")) // Direct import\n    ]).then(function (_ref3) {\n      var _ref4 = _slicedToArray(_ref3, 2),\n        markerModule = _ref4[0],\n        routeProcessor = _ref4[1];\n      // Manually create the markers without calculating routes\n      return Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./markerManager.js */ \"./markerManager.js\")).then(function (markerModule) {\n        // Create start marker without triggering route calc\n        // Handle the case whether setMarker returns a promise or the marker directly\n        var startMarkerResult = markerModule.setMarker(appState, L.latLng(startPoint.lat, startPoint.lng), 'start');\n\n        // Ensure we have a Promise regardless of what setMarker returns\n        var startMarkerPromise = startMarkerResult instanceof Promise ? startMarkerResult : Promise.resolve(startMarkerResult);\n        return startMarkerPromise.then(function () {\n          // Add waypoints if any\n          if (middlePoints.length > 0) {\n            return Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./waypointManager.js */ \"./waypointManager.js\")).then(function (waypointModule) {\n              // Add each waypoint\n              middlePoints.forEach(function (point) {\n                waypointModule.addWaypointFromLatLng(appState, L.latLng(point.lat, point.lng));\n              });\n\n              // Create end marker without triggering route calc\n              var endMarkerResult = markerModule.setMarker(appState, L.latLng(endPoint.lat, endPoint.lng), 'end');\n              var endMarkerPromise = endMarkerResult instanceof Promise ? endMarkerResult : Promise.resolve(endMarkerResult);\n              return endMarkerPromise.then(function () {\n                // Process route data using the new processor\n                return routeProcessor.processRoute(appState, parsedRouteData, {}).then(function () {\n                  // Then explicitly fit map to route to ensure it centers properly\n                  return __webpack_require__.e(/*! import() */ \"viewportManager_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./viewportManager.js */ \"./viewportManager.js\")).then(function (viewportManager) {\n                    console.log('Explicitly fitting map to route after localStorage load');\n                    // Using a timeout to ensure the route is fully rendered\n                    setTimeout(function () {\n                      return viewportManager.fitMapToRouteExplicit(appState);\n                    }, 300);\n                    return {\n                      routeLoaded: true\n                    };\n                  });\n                });\n              });\n            });\n          }\n          // No waypoints, just add end marker\n          var endMarkerResult = markerModule.setMarker(appState, L.latLng(endPoint.lat, endPoint.lng), 'end');\n          var endMarkerPromise = endMarkerResult instanceof Promise ? endMarkerResult : Promise.resolve(endMarkerResult);\n          return endMarkerPromise.then(function () {\n            // Process route data using the new processor\n            return routeProcessor.processRoute(appState, parsedRouteData, {}).then(function () {\n              // Then explicitly fit map to route to ensure it centers properly\n              return __webpack_require__.e(/*! import() */ \"viewportManager_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./viewportManager.js */ \"./viewportManager.js\")).then(function (viewportManager) {\n                console.log('Explicitly fitting map to route after localStorage load');\n                // Using a timeout to ensure the route is fully rendered\n                setTimeout(function () {\n                  return viewportManager.fitMapToRouteExplicit(appState);\n                }, 300);\n                return {\n                  routeLoaded: true\n                };\n              });\n            });\n          });\n        });\n      });\n    });\n  }\n  return Promise.resolve(); // Return a resolved promise if no data found\n}\n\n/**\n * Creates markers from URL route data\n * @param {Object} appState - Application state manager\n * @param {Array} pointsData - Array of points data\n * @returns {Promise} Promise resolving when markers are created\n */\nfunction createMarkersFromURLData(appState, pointsData) {\n  if (!pointsData || pointsData.length < 2) {\n    console.warn('Invalid points data for markers');\n    return Promise.resolve();\n  }\n  var startPoint = pointsData[0];\n  var endPoint = pointsData[pointsData.length - 1];\n  var middlePoints = pointsData.slice(1, -1);\n\n  // Create start marker\n  return Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./markerManager.js */ \"./markerManager.js\")).then(function (markerManager) {\n    return markerManager.setMarker(appState, L.latLng(startPoint.lat, startPoint.lng), 'start').then(function () {\n      // Add waypoints if there are any\n      if (middlePoints.length > 0) {\n        return Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./waypointManager.js */ \"./waypointManager.js\")).then(function (waypointManager) {\n          // Add waypoints sequentially\n          var chain = Promise.resolve();\n          middlePoints.forEach(function (point) {\n            chain = chain.then(function () {\n              return waypointManager.addWaypointAndUpdateRoute(appState, L.latLng(point.lat, point.lng));\n            });\n          });\n          return chain;\n        });\n      }\n      return Promise.resolve();\n    }).then(function () {\n      // Finally create end marker which will trigger route calculation\n      return markerManager.setMarker(appState, L.latLng(endPoint.lat, endPoint.lng), 'end');\n    });\n  });\n}\n\n/**\n * Generates a shareable URL for the current route\n * @param {Object} appState - Application state manager\n * @returns {Promise<string>} Promise resolving to shareable URL\n */\nfunction generateShareableURL(appState) {\n  var points = (0,_geometryUtils_js__WEBPACK_IMPORTED_MODULE_2__.getRoutePoints)(appState);\n  if (!points || points.length < 2) {\n    return Promise.reject(new Error('No valid route to share'));\n  }\n\n  // Compress the points data\n  var compressed = lz_string__WEBPACK_IMPORTED_MODULE_0__.compressToEncodedURIComponent(JSON.stringify(points));\n\n  // Build the URL with the compressed data\n  var url = new URL(window.location.href);\n  url.search = ''; // Clear existing query parameters\n  url.searchParams.set('points', compressed);\n  console.log('Generated shareable URL:', url.toString());\n  return Promise.resolve(url.toString());\n}\n\n/**\n * Encodes points data to a URL-friendly string\n * @param {Array} pointsData - Array of points\n * @returns {string} URL with encoded data\n */\nfunction encodePointsToUrl(pointsData) {\n  var simplePoints = pointsData.map(function (p) {\n    return {\n      lat: p.lat,\n      lng: p.lng\n    };\n  });\n  var compressed = lz_string__WEBPACK_IMPORTED_MODULE_0__.compressToEncodedURIComponent(JSON.stringify(simplePoints));\n  var baseUrl = window.location.origin + window.location.pathname;\n  return \"\".concat(baseUrl, \"?points=\").concat(compressed);\n}\n\n/**\n * Decodes points data from a URL\n * @returns {Promise} Promise resolving to array of points or null\n */\nfunction decodePointsFromUrl() {\n  var urlParams = new URLSearchParams(window.location.search);\n  var compressedPoints = urlParams.get('points');\n  console.log('URL params:', urlParams.toString());\n  console.log('Compressed points:', compressedPoints);\n  if (!compressedPoints) {\n    console.log('No points parameter found in URL');\n    return Promise.resolve(null);\n  }\n  try {\n    // Decompress the points data\n    var decompressed = lz_string__WEBPACK_IMPORTED_MODULE_0__.decompressFromEncodedURIComponent(compressedPoints);\n    console.log('Decompressed data:', decompressed);\n    if (!decompressed) {\n      console.error('Failed to decompress points data');\n      return Promise.resolve(null);\n    }\n    var pointsData = JSON.parse(decompressed);\n    console.log('Parsed points data:', pointsData);\n    return Promise.resolve(pointsData);\n  } catch (error) {\n    console.error('Error decoding points from URL:', error);\n    return Promise.resolve(null);\n  }\n}\n\n/**\n * Process URL parameters after route is created\n * @param {Object} appState - Application state manager\n */\nfunction processURLParameters(appState) {\n  var urlParams = new URLSearchParams(window.location.search);\n\n  // Check if we have route parameters\n  var hasRouteParams = urlParams.has('points');\n\n  // After successfully loading a route from parameters\n  if (hasRouteParams) {\n    // Give time for the route to be calculated and displayed\n    setTimeout(function () {\n      __webpack_require__.e(/*! import() */ \"viewportManager_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./viewportManager.js */ \"./viewportManager.js\")).then(function (viewportManager) {\n        viewportManager.fitMapToRouteExplicit(appState);\n      });\n    }, 200);\n  }\n}\n\n//# sourceURL=webpack://route-planner/./urlManager.js?");

/***/ })

}]);