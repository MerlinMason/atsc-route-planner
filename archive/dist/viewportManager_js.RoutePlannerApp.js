"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkroute_planner"] = self["webpackChunkroute_planner"] || []).push([["viewportManager_js"],{

/***/ "./viewportManager.js":
/*!****************************!*\
  !*** ./viewportManager.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   centerOnUserExplicit: () => (/* binding */ centerOnUserExplicit),\n/* harmony export */   fitMapToRouteExplicit: () => (/* binding */ fitMapToRouteExplicit),\n/* harmony export */   isInitialPositioningDone: () => (/* binding */ isInitialPositioningDone),\n/* harmony export */   resetPositioningState: () => (/* binding */ resetPositioningState),\n/* harmony export */   updateMapPosition: () => (/* binding */ updateMapPosition)\n/* harmony export */ });\n/* harmony import */ var _state_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./state.js */ \"./state.js\");\n/* harmony import */ var _geometryUtils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./geometryUtils.js */ \"./geometryUtils.js\");\n// viewportManager.js - Centralized management of map viewport positioning\n\n\n\n// Track whether initial positioning has been done\nvar initialPositioningDone = false;\n\n/**\n * Updates map position based on user location\n * @param {Object} appState - Application state manager\n * @param {Object} options - Positioning options\n * @param {boolean} options.userLocationAvailable - Whether user location is available\n * @param {boolean} options.skipInitialCenter - Whether to skip initial centering on user location\n */\nfunction updateMapPosition(appState) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _options$userLocation = options.userLocationAvailable,\n    userLocationAvailable = _options$userLocation === void 0 ? false : _options$userLocation,\n    _options$skipInitialC = options.skipInitialCenter,\n    skipInitialCenter = _options$skipInitialC === void 0 ? false : _options$skipInitialC;\n\n  // Only handle user location positioning here if not explicitly skipped\n  if (userLocationAvailable && appState.getUserCoords() && !skipInitialCenter) {\n    if (!initialPositioningDone) {\n      console.log('Centering map on user location:', appState.getUserCoords());\n      appState.getMap().setView(appState.getUserCoords(), 16);\n      initialPositioningDone = true;\n      return;\n    }\n  } else if (userLocationAvailable && skipInitialCenter) {\n    // Mark positioning as done but don't center\n    initialPositioningDone = true;\n    console.log('Initial centering on user skipped (route loading in progress)');\n  }\n\n  // Handle follow mode\n  if (appState.isFollowingUser() && appState.getUserCoords()) {\n    console.log('Following user, updating map center');\n    appState.getMap().setView(appState.getUserCoords(), appState.getMap().getZoom());\n  }\n}\n\n/**\n * Explicitly fits the map to the current route\n * @param {Object} appState - Application state manager\n * @returns {Promise<boolean>} Promise that resolves with whether the fit was successful\n */\nfunction fitMapToRouteExplicit(appState) {\n  if (!appState.getMap() || !appState.isMapReady()) {\n    console.warn('Cannot fit map to route: Map not ready');\n    return Promise.resolve(false);\n  }\n  if (!appState.getRouteLine()) {\n    console.warn('Cannot fit map to route: No route to fit');\n    return Promise.resolve(false);\n  }\n\n  // Extra check to ensure route has valid bounds\n  var routeLine = appState.getRouteLine();\n  if (!routeLine.getBounds || !routeLine.getBounds().isValid()) {\n    console.warn('Cannot fit map to route: Route has invalid bounds');\n    return Promise.resolve(false);\n  }\n  console.log('Fitting map to route');\n  return new Promise(function (resolve) {\n    var result = (0,_geometryUtils_js__WEBPACK_IMPORTED_MODULE_1__.fitMapToRoute)(appState);\n    if (result) {\n      console.log('Successfully fitted map to route');\n    } else {\n      console.warn('Failed to fit map to route');\n    }\n    initialPositioningDone = true;\n    resolve(result);\n  });\n}\n\n/**\n * Explicitly centers the map on user location\n * @param {Object} appState - Application state manager\n */\nfunction centerOnUserExplicit(appState) {\n  if (!appState.getUserCoords()) {\n    console.log('No user location to center on');\n    return false;\n  }\n  console.log('Explicitly centering on user');\n  appState.getMap().setView(appState.getUserCoords(), 16);\n  return true;\n}\n\n/**\n * Resets the positioning state (e.g. when clearing route)\n */\nfunction resetPositioningState() {\n  initialPositioningDone = false;\n}\n\n/**\n * Gets whether initial positioning has been done\n * @returns {boolean} Whether initial positioning is done\n */\nfunction isInitialPositioningDone() {\n  return initialPositioningDone;\n}\n\n//# sourceURL=webpack://route-planner/./viewportManager.js?");

/***/ })

}]);